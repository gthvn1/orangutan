(*
   Simple stack-based virtual machine.

   This virtual machine executes a small bytecode designed to evaluate
   arithmetic expressions. The bytecode is produced by compiling the AST
   generated by the parser (see parser.ml).

   Execution model:
   - The VM is stack-based: all intermediate values are stored on a stack.
   - Instructions either push values onto the stack or pop values from it
     to perform computations.
   - Binary operations (Add, Sub, Mul, Div) pop their operands from the stack
     and push the result.
   - Unary operations (Neg) pop one value and push the transformed result.
   - At the end of execution, the stack is expected to contain exactly one
     value: the result of the expression.

   This VM is intentionally minimal:
   - No variables or environment
   - No control flow or jumps
   - No memory beyond the operand stack

    Instruction set (stack effect notation uses top-of-stack on the right):

     Push n
       Stack effect: [] -> [n]
       Pushes the integer [n] onto the stack.

     Add
       Stack effect: [a; b] -> [a + b]
       Pops the two topmost integers from the stack and pushes their sum.
       The top of the stack is considered the right operand.

     Sub
       Stack effect: [a; b] -> [a - b]
       Pops the two topmost integers and pushes their difference.

     Mul
       Stack effect: [a; b] -> [a * b]
       Pops the two topmost integers and pushes their product.

     Div
       Stack effect: [a; b] -> [a / b]
       Pops the two topmost integers and pushes the result of integer division.
       Division by zero is an error.

     Neg
       Stack effect: [a] -> [-a]
       Pops the topmost integer and pushes its negation.
*)
type insn = Push of int | Add | Sub | Mul | Div | Neg

let run (code : insn list) =
  let open Stack in
  let stack = create () in
  List.iter
    (fun insn ->
      match insn with
      | Push x -> push x stack
      | Add ->
          let b = pop stack in
          let a = pop stack in
          push (a + b) stack
      | Sub ->
          let b = pop stack in
          let a = pop stack in
          push (a - b) stack
      | Mul ->
          let b = pop stack in
          let a = pop stack in
          push (a * b) stack
      | Div ->
          let b = pop stack in
          let a = pop stack in
          push (a / b) stack
      | Neg ->
          let a = pop stack in
          push (-a) stack)
    code;
  (* Result is on top of the stack *)
  pop stack
